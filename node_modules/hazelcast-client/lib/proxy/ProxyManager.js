"use strict";
/*
 * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @ignore */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyManager = exports.NAMESPACE_SEPARATOR = void 0;
const ClientAddDistributedObjectListenerCodec_1 = require("../codec/ClientAddDistributedObjectListenerCodec");
const ClientCreateProxyCodec_1 = require("../codec/ClientCreateProxyCodec");
const ClientDestroyProxyCodec_1 = require("../codec/ClientDestroyProxyCodec");
const ClientRemoveDistributedObjectListenerCodec_1 = require("../codec/ClientRemoveDistributedObjectListenerCodec");
const InvocationService_1 = require("../invocation/InvocationService");
const FlakeIdGeneratorProxy_1 = require("./flakeid/FlakeIdGeneratorProxy");
const ListProxy_1 = require("./ListProxy");
const MapProxy_1 = require("./MapProxy");
const MultiMapProxy_1 = require("./MultiMapProxy");
const NearCachedMapProxy_1 = require("./NearCachedMapProxy");
const PNCounterProxy_1 = require("./PNCounterProxy");
const QueueProxy_1 = require("./QueueProxy");
const ReplicatedMapProxy_1 = require("./ReplicatedMapProxy");
const RingbufferProxy_1 = require("./ringbuffer/RingbufferProxy");
const SetProxy_1 = require("./SetProxy");
const ReliableTopicProxy_1 = require("./topic/ReliableTopicProxy");
const DistributedObjectListener_1 = require("../core/DistributedObjectListener");
const Util_1 = require("../util/Util");
const ClientCreateProxiesCodec_1 = require("../codec/ClientCreateProxiesCodec");
/** @internal */
exports.NAMESPACE_SEPARATOR = '/';
const RINGBUFFER_PREFIX = '_hz_rb_';
/** @internal */
class ProxyManager {
    constructor(client) {
        this.service = {};
        this.proxies = new Map();
        this.client = client;
    }
    init() {
        this.service[ProxyManager.MAP_SERVICE] = MapProxy_1.MapProxy;
        this.service[ProxyManager.SET_SERVICE] = SetProxy_1.SetProxy;
        this.service[ProxyManager.QUEUE_SERVICE] = QueueProxy_1.QueueProxy;
        this.service[ProxyManager.LIST_SERVICE] = ListProxy_1.ListProxy;
        this.service[ProxyManager.MULTIMAP_SERVICE] = MultiMapProxy_1.MultiMapProxy;
        this.service[ProxyManager.RINGBUFFER_SERVICE] = RingbufferProxy_1.RingbufferProxy;
        this.service[ProxyManager.REPLICATEDMAP_SERVICE] = ReplicatedMapProxy_1.ReplicatedMapProxy;
        this.service[ProxyManager.FLAKEID_SERVICE] = FlakeIdGeneratorProxy_1.FlakeIdGeneratorProxy;
        this.service[ProxyManager.PNCOUNTER_SERVICE] = PNCounterProxy_1.PNCounterProxy;
        this.service[ProxyManager.RELIABLETOPIC_SERVICE] = ReliableTopicProxy_1.ReliableTopicProxy;
    }
    getOrCreateProxy(name, serviceName, createAtServer = true) {
        const fullName = serviceName + exports.NAMESPACE_SEPARATOR + name;
        if (this.proxies.has(fullName)) {
            return this.proxies.get(fullName);
        }
        const deferred = Util_1.deferredPromise();
        this.proxies.set(fullName, deferred.promise);
        let createProxyPromise;
        if (createAtServer) {
            createProxyPromise = this.createProxy(name, serviceName);
        }
        else {
            createProxyPromise = Promise.resolve();
        }
        createProxyPromise
            .then(() => {
            return this.initializeLocalProxy(name, serviceName, createAtServer);
        })
            .then((localProxy) => {
            deferred.resolve(localProxy);
        })
            .catch((error) => {
            this.proxies.delete(fullName);
            deferred.reject(error);
        });
        return deferred.promise;
    }
    createDistributedObjectsOnCluster() {
        const proxyEntries = new Array(this.proxies.size);
        let index = 0;
        this.proxies.forEach((_, namespace) => {
            const separatorIndex = namespace.indexOf(exports.NAMESPACE_SEPARATOR);
            const serviceName = namespace.substring(0, separatorIndex);
            const name = namespace.substring(separatorIndex + 1);
            proxyEntries[index++] = [name, serviceName];
        });
        if (proxyEntries.length === 0) {
            return Promise.resolve();
        }
        const request = ClientCreateProxiesCodec_1.ClientCreateProxiesCodec.encodeRequest(proxyEntries);
        request.setPartitionId(-1);
        const invocation = new InvocationService_1.Invocation(this.client, request);
        return this.client.getInvocationService().invokeUrgent(invocation).then(() => { });
    }
    getDistributedObjects() {
        const promises = new Array(this.proxies.size);
        let index = 0;
        this.proxies.forEach((proxy) => {
            promises[index++] = proxy;
        });
        return Promise.all(promises);
    }
    destroyProxy(name, serviceName) {
        this.proxies.delete(serviceName + exports.NAMESPACE_SEPARATOR + name);
        const clientMessage = ClientDestroyProxyCodec_1.ClientDestroyProxyCodec.encodeRequest(name, serviceName);
        clientMessage.setPartitionId(-1);
        return this.client.getInvocationService().invokeOnRandomTarget(clientMessage).then(() => { });
    }
    destroyProxyLocally(namespace) {
        const proxy = this.proxies.get(namespace);
        if (proxy != null) {
            this.proxies.delete(namespace);
            return proxy.then((distributedObject) => {
                return distributedObject.destroyLocally();
            });
        }
        return Promise.resolve();
    }
    addDistributedObjectListener(distributedObjectListener) {
        const handler = (clientMessage) => {
            const converterFunc = (objectName, serviceName, eventType) => {
                eventType = eventType.toLowerCase();
                const distributedObjectEvent = new DistributedObjectListener_1.DistributedObjectEvent(eventType, serviceName, objectName);
                distributedObjectListener(distributedObjectEvent);
            };
            ClientAddDistributedObjectListenerCodec_1.ClientAddDistributedObjectListenerCodec.handle(clientMessage, converterFunc);
        };
        const codec = this.createDistributedObjectListener();
        return this.client.getListenerService().registerListener(codec, handler);
    }
    removeDistributedObjectListener(listenerId) {
        return this.client.getListenerService().deregisterListener(listenerId);
    }
    destroy() {
        this.proxies.clear();
    }
    createProxy(name, serviceName) {
        const request = ClientCreateProxyCodec_1.ClientCreateProxyCodec.encodeRequest(name, serviceName);
        return this.client.getInvocationService().invokeOnRandomTarget(request);
    }
    createDistributedObjectListener() {
        return {
            encodeAddRequest(localOnly) {
                return ClientAddDistributedObjectListenerCodec_1.ClientAddDistributedObjectListenerCodec.encodeRequest(localOnly);
            },
            decodeAddResponse(msg) {
                return ClientAddDistributedObjectListenerCodec_1.ClientAddDistributedObjectListenerCodec.decodeResponse(msg);
            },
            encodeRemoveRequest(listenerId) {
                return ClientRemoveDistributedObjectListenerCodec_1.ClientRemoveDistributedObjectListenerCodec.encodeRequest(listenerId);
            },
        };
    }
    initializeLocalProxy(name, serviceName, createAtServer) {
        let localProxy;
        const config = this.client.getConfig();
        if (serviceName === ProxyManager.MAP_SERVICE && config.getNearCacheConfig(name)) {
            localProxy = new NearCachedMapProxy_1.NearCachedMapProxy(this.client, serviceName, name);
        }
        else {
            // This call may throw ClientOfflineError for partition specific proxies with async start
            localProxy = new this.service[serviceName](this.client, serviceName, name);
        }
        if (serviceName === ProxyManager.RELIABLETOPIC_SERVICE) {
            return this.getOrCreateProxy(RINGBUFFER_PREFIX + name, ProxyManager.RINGBUFFER_SERVICE, createAtServer)
                .then((ringbuffer) => {
                localProxy.setRingbuffer(ringbuffer);
                return localProxy;
            });
        }
        else {
            return Promise.resolve(localProxy);
        }
    }
}
exports.ProxyManager = ProxyManager;
ProxyManager.MAP_SERVICE = 'hz:impl:mapService';
ProxyManager.SET_SERVICE = 'hz:impl:setService';
ProxyManager.LOCK_SERVICE = 'hz:impl:lockService';
ProxyManager.QUEUE_SERVICE = 'hz:impl:queueService';
ProxyManager.LIST_SERVICE = 'hz:impl:listService';
ProxyManager.MULTIMAP_SERVICE = 'hz:impl:multiMapService';
ProxyManager.RINGBUFFER_SERVICE = 'hz:impl:ringbufferService';
ProxyManager.REPLICATEDMAP_SERVICE = 'hz:impl:replicatedMapService';
ProxyManager.FLAKEID_SERVICE = 'hz:impl:flakeIdGeneratorService';
ProxyManager.PNCOUNTER_SERVICE = 'hz:impl:PNCounterService';
ProxyManager.RELIABLETOPIC_SERVICE = 'hz:impl:reliableTopicService';
