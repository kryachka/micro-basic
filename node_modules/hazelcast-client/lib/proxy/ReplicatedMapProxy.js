"use strict";
/*
 * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplicatedMapProxy = void 0;
const core_1 = require("../core");
const ReplicatedMapAddEntryListenerCodec_1 = require("../codec/ReplicatedMapAddEntryListenerCodec");
const ReplicatedMapAddEntryListenerToKeyCodec_1 = require("../codec/ReplicatedMapAddEntryListenerToKeyCodec");
// eslint-disable-next-line max-len
const ReplicatedMapAddEntryListenerToKeyWithPredicateCodec_1 = require("../codec/ReplicatedMapAddEntryListenerToKeyWithPredicateCodec");
const ReplicatedMapAddEntryListenerWithPredicateCodec_1 = require("../codec/ReplicatedMapAddEntryListenerWithPredicateCodec");
const ReplicatedMapClearCodec_1 = require("../codec/ReplicatedMapClearCodec");
const ReplicatedMapContainsKeyCodec_1 = require("../codec/ReplicatedMapContainsKeyCodec");
const ReplicatedMapContainsValueCodec_1 = require("../codec/ReplicatedMapContainsValueCodec");
const ReplicatedMapEntrySetCodec_1 = require("../codec/ReplicatedMapEntrySetCodec");
const ReplicatedMapGetCodec_1 = require("../codec/ReplicatedMapGetCodec");
const ReplicatedMapIsEmptyCodec_1 = require("../codec/ReplicatedMapIsEmptyCodec");
const ReplicatedMapKeySetCodec_1 = require("../codec/ReplicatedMapKeySetCodec");
const ReplicatedMapPutAllCodec_1 = require("../codec/ReplicatedMapPutAllCodec");
const ReplicatedMapPutCodec_1 = require("../codec/ReplicatedMapPutCodec");
const ReplicatedMapRemoveCodec_1 = require("../codec/ReplicatedMapRemoveCodec");
const ReplicatedMapRemoveEntryListenerCodec_1 = require("../codec/ReplicatedMapRemoveEntryListenerCodec");
const ReplicatedMapSizeCodec_1 = require("../codec/ReplicatedMapSizeCodec");
const ReplicatedMapValuesCodec_1 = require("../codec/ReplicatedMapValuesCodec");
const EventType_1 = require("./EventType");
const EntryListener_1 = require("./EntryListener");
const Util_1 = require("../util/Util");
const PartitionSpecificProxy_1 = require("./PartitionSpecificProxy");
const MapListener_1 = require("./MapListener");
const SerializationUtil_1 = require("../serialization/SerializationUtil");
class ReplicatedMapProxy extends PartitionSpecificProxy_1.PartitionSpecificProxy {
    put(key, value, ttl = 0) {
        Util_1.assertNotNull(key);
        Util_1.assertNotNull(value);
        const valueData = this.toData(value);
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(ReplicatedMapPutCodec_1.ReplicatedMapPutCodec, keyData, keyData, valueData, ttl)
            .then((clientMessage) => {
            const response = ReplicatedMapPutCodec_1.ReplicatedMapPutCodec.decodeResponse(clientMessage);
            return this.toObject(response);
        });
    }
    clear() {
        return this.encodeInvokeOnRandomTarget(ReplicatedMapClearCodec_1.ReplicatedMapClearCodec).then(() => { });
    }
    get(key) {
        Util_1.assertNotNull(key);
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(ReplicatedMapGetCodec_1.ReplicatedMapGetCodec, keyData, keyData)
            .then((clientMessage) => {
            const response = ReplicatedMapGetCodec_1.ReplicatedMapGetCodec.decodeResponse(clientMessage);
            return this.toObject(response);
        });
    }
    containsKey(key) {
        Util_1.assertNotNull(key);
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(ReplicatedMapContainsKeyCodec_1.ReplicatedMapContainsKeyCodec, keyData, keyData)
            .then(ReplicatedMapContainsKeyCodec_1.ReplicatedMapContainsKeyCodec.decodeResponse);
    }
    containsValue(value) {
        Util_1.assertNotNull(value);
        const valueData = this.toData(value);
        return this.encodeInvoke(ReplicatedMapContainsValueCodec_1.ReplicatedMapContainsValueCodec, valueData)
            .then(ReplicatedMapContainsValueCodec_1.ReplicatedMapContainsValueCodec.decodeResponse);
    }
    size() {
        return this.encodeInvoke(ReplicatedMapSizeCodec_1.ReplicatedMapSizeCodec)
            .then(ReplicatedMapSizeCodec_1.ReplicatedMapSizeCodec.decodeResponse);
    }
    isEmpty() {
        return this.encodeInvoke(ReplicatedMapIsEmptyCodec_1.ReplicatedMapIsEmptyCodec)
            .then(ReplicatedMapIsEmptyCodec_1.ReplicatedMapIsEmptyCodec.decodeResponse);
    }
    remove(key) {
        Util_1.assertNotNull(key);
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(ReplicatedMapRemoveCodec_1.ReplicatedMapRemoveCodec, keyData, keyData)
            .then((clientMessage) => {
            const response = ReplicatedMapRemoveCodec_1.ReplicatedMapRemoveCodec.decodeResponse(clientMessage);
            return this.toObject(response);
        });
    }
    putAll(pairs) {
        let pair;
        let pairId;
        const entries = [];
        for (pairId in pairs) {
            pair = pairs[pairId];
            const keyData = this.toData(pair[0]);
            const valueData = this.toData(pair[1]);
            entries.push([keyData, valueData]);
        }
        return this.encodeInvokeOnRandomTarget(ReplicatedMapPutAllCodec_1.ReplicatedMapPutAllCodec, entries).then(() => { });
    }
    keySet() {
        const toObject = this.toObject.bind(this);
        return this.encodeInvoke(ReplicatedMapKeySetCodec_1.ReplicatedMapKeySetCodec)
            .then((clientMessage) => {
            const response = ReplicatedMapKeySetCodec_1.ReplicatedMapKeySetCodec.decodeResponse(clientMessage);
            return response.map(toObject);
        });
    }
    values(comparator) {
        return this.encodeInvoke(ReplicatedMapValuesCodec_1.ReplicatedMapValuesCodec)
            .then((clientMessage) => {
            const valuesData = ReplicatedMapValuesCodec_1.ReplicatedMapValuesCodec.decodeResponse(clientMessage);
            if (comparator) {
                const desValues = valuesData.map(this.toObject.bind(this));
                return new core_1.ReadOnlyLazyList(desValues.sort(comparator), this.client.getSerializationService());
            }
            return new core_1.ReadOnlyLazyList(valuesData, this.client.getSerializationService());
        });
    }
    entrySet() {
        return this.encodeInvoke(ReplicatedMapEntrySetCodec_1.ReplicatedMapEntrySetCodec)
            .then((clientMessage) => {
            const response = ReplicatedMapEntrySetCodec_1.ReplicatedMapEntrySetCodec.decodeResponse(clientMessage);
            return SerializationUtil_1.deserializeEntryList(this.toObject.bind(this), response);
        });
    }
    addEntryListenerToKeyWithPredicate(listener, key, predicate) {
        return this.addEntryListenerInternal(listener, predicate, key);
    }
    addEntryListenerWithPredicate(listener, predicate) {
        return this.addEntryListenerInternal(listener, predicate, undefined);
    }
    addEntryListenerToKey(listener, key) {
        return this.addEntryListenerInternal(listener, undefined, key);
    }
    addEntryListener(listener) {
        return this.addEntryListenerInternal(listener, undefined, undefined);
    }
    removeEntryListener(listenerId) {
        return this.client.getListenerService().deregisterListener(listenerId);
    }
    addEntryListenerInternal(listener, predicate, key) {
        const toObject = this.toObject.bind(this);
        const entryEventHandler = (key, value, oldValue, mergingValue, event, uuid, numberOfAffectedEntries) => {
            const member = this.client.getClusterService().getMember(uuid);
            const name = this.name;
            key = toObject(key);
            value = toObject(value);
            oldValue = toObject(oldValue);
            mergingValue = toObject(mergingValue);
            const entryEvent = new EntryListener_1.EntryEvent(name, key, value, oldValue, mergingValue, member);
            const mapEvent = new MapListener_1.MapEvent(name, numberOfAffectedEntries, member);
            const entryEventToListenerMap = {
                [EventType_1.EventType.ADDED]: 'added',
                [EventType_1.EventType.REMOVED]: 'removed',
                [EventType_1.EventType.UPDATED]: 'updated',
                [EventType_1.EventType.EVICTED]: 'evicted',
            };
            const mapEventToListenerMap = {
                [EventType_1.EventType.CLEAR_ALL]: 'mapCleared',
            };
            const entryEventMethod = entryEventToListenerMap[event];
            const mapEventMethod = mapEventToListenerMap[event];
            if (listener.hasOwnProperty(entryEventMethod)) {
                listener[entryEventMethod].apply(null, [entryEvent]);
            }
            else if (listener.hasOwnProperty(mapEventMethod)) {
                listener[mapEventMethod].apply(null, [mapEvent]);
            }
        };
        let listenerHandler;
        let codec;
        if (key && predicate) {
            const keyData = this.toData(key);
            const predicateData = this.toData(predicate);
            codec = this.createEntryListenerToKeyWithPredicate(this.name, keyData, predicateData);
            listenerHandler = ReplicatedMapAddEntryListenerToKeyWithPredicateCodec_1.ReplicatedMapAddEntryListenerToKeyWithPredicateCodec.handle;
        }
        else if (key && !predicate) {
            const keyData = this.toData(key);
            codec = this.createEntryListenerToKey(this.name, keyData);
            listenerHandler = ReplicatedMapAddEntryListenerToKeyCodec_1.ReplicatedMapAddEntryListenerToKeyCodec.handle;
        }
        else if (!key && predicate) {
            const predicateData = this.toData(predicate);
            codec = this.createEntryListenerWithPredicate(this.name, predicateData);
            listenerHandler = ReplicatedMapAddEntryListenerWithPredicateCodec_1.ReplicatedMapAddEntryListenerWithPredicateCodec.handle;
        }
        else {
            codec = this.createEntryListener(this.name);
            listenerHandler = ReplicatedMapAddEntryListenerCodec_1.ReplicatedMapAddEntryListenerCodec.handle;
        }
        return this.client.getListenerService().registerListener(codec, (m) => {
            listenerHandler(m, entryEventHandler, toObject);
        });
    }
    createEntryListener(name) {
        return {
            encodeAddRequest(localOnly) {
                return ReplicatedMapAddEntryListenerCodec_1.ReplicatedMapAddEntryListenerCodec.encodeRequest(name, localOnly);
            },
            decodeAddResponse(msg) {
                return ReplicatedMapAddEntryListenerCodec_1.ReplicatedMapAddEntryListenerCodec.decodeResponse(msg);
            },
            encodeRemoveRequest(listenerId) {
                return ReplicatedMapRemoveEntryListenerCodec_1.ReplicatedMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);
            },
        };
    }
    createEntryListenerToKey(name, keyData) {
        return {
            encodeAddRequest(localOnly) {
                return ReplicatedMapAddEntryListenerToKeyCodec_1.ReplicatedMapAddEntryListenerToKeyCodec.encodeRequest(name, keyData, localOnly);
            },
            decodeAddResponse(msg) {
                return ReplicatedMapAddEntryListenerToKeyCodec_1.ReplicatedMapAddEntryListenerToKeyCodec.decodeResponse(msg);
            },
            encodeRemoveRequest(listenerId) {
                return ReplicatedMapRemoveEntryListenerCodec_1.ReplicatedMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);
            },
        };
    }
    createEntryListenerWithPredicate(name, predicateData) {
        return {
            encodeAddRequest(localOnly) {
                return ReplicatedMapAddEntryListenerWithPredicateCodec_1.ReplicatedMapAddEntryListenerWithPredicateCodec.encodeRequest(name, predicateData, localOnly);
            },
            decodeAddResponse(msg) {
                return ReplicatedMapAddEntryListenerWithPredicateCodec_1.ReplicatedMapAddEntryListenerWithPredicateCodec.decodeResponse(msg);
            },
            encodeRemoveRequest(listenerId) {
                return ReplicatedMapRemoveEntryListenerCodec_1.ReplicatedMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);
            },
        };
    }
    createEntryListenerToKeyWithPredicate(name, keyData, predicateData) {
        return {
            encodeAddRequest(localOnly) {
                return ReplicatedMapAddEntryListenerToKeyWithPredicateCodec_1.ReplicatedMapAddEntryListenerToKeyWithPredicateCodec.encodeRequest(name, keyData, predicateData, localOnly);
            },
            decodeAddResponse(msg) {
                return ReplicatedMapAddEntryListenerToKeyWithPredicateCodec_1.ReplicatedMapAddEntryListenerToKeyWithPredicateCodec.decodeResponse(msg);
            },
            encodeRemoveRequest(listenerId) {
                return ReplicatedMapRemoveEntryListenerCodec_1.ReplicatedMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);
            },
        };
    }
}
exports.ReplicatedMapProxy = ReplicatedMapProxy;
