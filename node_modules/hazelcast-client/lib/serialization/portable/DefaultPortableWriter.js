"use strict";
/*
 * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @ignore */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultPortableWriter = void 0;
const BitsUtil_1 = require("../../util/BitsUtil");
const Portable_1 = require("../Portable");
/** @internal */
class DefaultPortableWriter {
    constructor(serializer, output, classDefinition) {
        this.serializer = serializer;
        this.output = output;
        this.classDefinition = classDefinition;
        this.begin = this.output.position();
        this.output.writeZeroBytes(4);
        this.output.writeInt(this.classDefinition.getFieldCount());
        this.offset = this.output.position();
        const fieldIndexesLength = (this.classDefinition.getFieldCount() + 1) * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;
        this.output.writeZeroBytes(fieldIndexesLength);
    }
    writeInt(fieldName, value) {
        this.setPosition(fieldName, Portable_1.FieldType.INT);
        this.output.writeInt(value);
    }
    writeLong(fieldName, long) {
        this.setPosition(fieldName, Portable_1.FieldType.LONG);
        this.output.writeLong(long);
    }
    writeUTF(fieldName, str) {
        this.setPosition(fieldName, Portable_1.FieldType.UTF);
        this.output.writeUTF(str);
    }
    writeBoolean(fieldName, value) {
        this.setPosition(fieldName, Portable_1.FieldType.BOOLEAN);
        this.output.writeBoolean(value);
    }
    writeByte(fieldName, value) {
        this.setPosition(fieldName, Portable_1.FieldType.BYTE);
        this.output.writeByte(value);
    }
    writeChar(fieldName, char) {
        this.setPosition(fieldName, Portable_1.FieldType.CHAR);
        this.output.writeChar(char);
    }
    writeDouble(fieldName, double) {
        this.setPosition(fieldName, Portable_1.FieldType.DOUBLE);
        this.output.writeDouble(double);
    }
    writeFloat(fieldName, float) {
        this.setPosition(fieldName, Portable_1.FieldType.FLOAT);
        this.output.writeFloat(float);
    }
    writeShort(fieldName, value) {
        this.setPosition(fieldName, Portable_1.FieldType.SHORT);
        this.output.writeShort(value);
    }
    writePortable(fieldName, portable) {
        const fieldDefinition = this.setPosition(fieldName, Portable_1.FieldType.PORTABLE);
        const isNullPortable = (portable == null);
        this.output.writeBoolean(isNullPortable);
        this.output.writeInt(fieldDefinition.getFactoryId());
        this.output.writeInt(fieldDefinition.getClassId());
        if (!isNullPortable) {
            this.serializer.writeObject(this.output, portable);
        }
    }
    writeNullPortable(fieldName, factoryId, classId) {
        this.setPosition(fieldName, Portable_1.FieldType.PORTABLE);
        this.output.writeBoolean(true);
        this.output.writeInt(factoryId);
        this.output.writeInt(classId);
    }
    writeByteArray(fieldName, bytes) {
        this.setPosition(fieldName, Portable_1.FieldType.BYTE_ARRAY);
        this.output.writeByteArray(bytes);
    }
    writeBooleanArray(fieldName, booleans) {
        this.setPosition(fieldName, Portable_1.FieldType.BOOLEAN_ARRAY);
        this.output.writeBooleanArray(booleans);
    }
    writeCharArray(fieldName, chars) {
        this.setPosition(fieldName, Portable_1.FieldType.CHAR_ARRAY);
        this.output.writeCharArray(chars);
    }
    writeIntArray(fieldName, ints) {
        this.setPosition(fieldName, Portable_1.FieldType.INT_ARRAY);
        this.output.writeIntArray(ints);
    }
    writeLongArray(fieldName, longs) {
        this.setPosition(fieldName, Portable_1.FieldType.LONG_ARRAY);
        this.output.writeLongArray(longs);
    }
    writeDoubleArray(fieldName, doubles) {
        this.setPosition(fieldName, Portable_1.FieldType.DOUBLE_ARRAY);
        this.output.writeDoubleArray(doubles);
    }
    writeFloatArray(fieldName, floats) {
        this.setPosition(fieldName, Portable_1.FieldType.FLOAT_ARRAY);
        this.output.writeFloatArray(floats);
    }
    writeShortArray(fieldName, shorts) {
        this.setPosition(fieldName, Portable_1.FieldType.SHORT_ARRAY);
        this.output.writeShortArray(shorts);
    }
    writeUTFArray(fieldName, val) {
        this.setPosition(fieldName, Portable_1.FieldType.UTF_ARRAY);
        this.output.writeUTFArray(val);
    }
    writePortableArray(fieldName, portables) {
        let innerOffset;
        let sample;
        let i;
        const fieldDefinition = this.setPosition(fieldName, Portable_1.FieldType.PORTABLE_ARRAY);
        const len = (portables == null) ? BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH : portables.length;
        this.output.writeInt(len);
        this.output.writeInt(fieldDefinition.getFactoryId());
        this.output.writeInt(fieldDefinition.getClassId());
        if (len > 0) {
            innerOffset = this.output.position();
            this.output.writeZeroBytes(len * 4);
            for (i = 0; i < len; i++) {
                sample = portables[i];
                const posVal = this.output.position();
                this.output.pwriteInt(innerOffset + i * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, posVal);
                this.serializer.writeObject(this.output, sample);
            }
        }
    }
    end() {
        const position = this.output.position();
        this.output.pwriteInt(this.begin, position);
    }
    setPosition(fieldName, fieldType) {
        const field = this.classDefinition.getField(fieldName);
        const pos = this.output.position();
        const index = field.getIndex();
        this.output.pwriteInt(this.offset + index * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, pos);
        this.output.writeShort(fieldName.length);
        this.output.write(Buffer.from(fieldName));
        this.output.writeByte(fieldType);
        return field;
    }
}
exports.DefaultPortableWriter = DefaultPortableWriter;
