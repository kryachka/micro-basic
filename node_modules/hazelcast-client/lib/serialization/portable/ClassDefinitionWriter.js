"use strict";
/*
 * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @ignore */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassDefinitionWriter = void 0;
const ClassDefinitionBuilder_1 = require("./ClassDefinitionBuilder");
const core_1 = require("../../core");
/** @internal */
class ClassDefinitionWriter {
    constructor(context, builder) {
        this.context = context;
        this.builder = builder;
    }
    writeInt(fieldName, value) {
        this.builder.addIntField(fieldName);
    }
    writeLong(fieldName, long) {
        this.builder.addLongField(fieldName);
    }
    writeUTF(fieldName, str) {
        this.builder.addUTFField(fieldName);
    }
    writeBoolean(fieldName, value) {
        this.builder.addBooleanField(fieldName);
    }
    writeByte(fieldName, value) {
        this.builder.addByteField(fieldName);
    }
    writeChar(fieldName, char) {
        this.builder.addCharField(fieldName);
    }
    writeDouble(fieldName, double) {
        this.builder.addDoubleField(fieldName);
    }
    writeFloat(fieldName, float) {
        this.builder.addFloatField(fieldName);
    }
    writeShort(fieldName, value) {
        this.builder.addShortField(fieldName);
    }
    writePortable(fieldName, portable) {
        if (portable == null) {
            throw new core_1.HazelcastSerializationError('Cannot write null portable without explicitly '
                + 'registering class definition!');
        }
        const version = this.context.getClassVersion(portable);
        const nestedClassDef = this.createNestedClassDef(portable, new ClassDefinitionBuilder_1.ClassDefinitionBuilder(portable.factoryId, portable.classId, version));
        this.builder.addPortableField(fieldName, nestedClassDef);
    }
    writeNullPortable(fieldName, factoryId, classId) {
        const nestedClassDef = this.context.lookupClassDefinition(factoryId, classId, this.context.getVersion());
        if (nestedClassDef == null) {
            throw new core_1.HazelcastSerializationError('Cannot write null portable without explicitly '
                + 'registering class definition!');
        }
        this.builder.addPortableField(fieldName, nestedClassDef);
    }
    writeByteArray(fieldName, bytes) {
        this.builder.addByteArrayField(fieldName);
    }
    writeBooleanArray(fieldName, booleans) {
        this.builder.addBooleanArrayField(fieldName);
    }
    writeCharArray(fieldName, chars) {
        this.builder.addCharArrayField(fieldName);
    }
    writeIntArray(fieldName, ints) {
        this.builder.addIntArrayField(fieldName);
    }
    writeLongArray(fieldName, longs) {
        this.builder.addLongArrayField(fieldName);
    }
    writeDoubleArray(fieldName, doubles) {
        this.builder.addDoubleArrayField(fieldName);
    }
    writeFloatArray(fieldName, floats) {
        this.builder.addFloatArrayField(fieldName);
    }
    writeShortArray(fieldName, shorts) {
        this.builder.addShortArrayField(fieldName);
    }
    writeUTFArray(fieldName, val) {
        this.builder.addUTFArrayField(fieldName);
    }
    writePortableArray(fieldName, portables) {
        if (portables == null || portables.length === 0) {
            throw new core_1.HazelcastSerializationError('Cannot write null portable array without explicitly '
                + 'registering class definition!');
        }
        const portable = portables[0];
        const classId = portable.classId;
        for (let i = 1; i < portables.length; i++) {
            if (portables[i].classId !== classId) {
                throw new RangeError('Detected different class-ids in portable array!');
            }
        }
        const version = this.context.getClassVersion(portable);
        const nestedClassDef = this.createNestedClassDef(portable, new ClassDefinitionBuilder_1.ClassDefinitionBuilder(portable.factoryId, portable.classId, version));
        this.builder.addPortableArrayField(fieldName, nestedClassDef);
    }
    registerAndGet() {
        const cd = this.builder.build();
        return this.context.registerClassDefinition(cd);
    }
    createNestedClassDef(portable, nestedBuilder) {
        const writer = new ClassDefinitionWriter(this.context, nestedBuilder);
        portable.writePortable(writer);
        return this.context.registerClassDefinition(nestedBuilder.build());
    }
}
exports.ClassDefinitionWriter = ClassDefinitionWriter;
