"use strict";
/*
 * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @ignore */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerializationServiceV1 = void 0;
const AggregatorFactory_1 = require("../aggregation/AggregatorFactory");
const ClusterDataFactory_1 = require("./ClusterDataFactory");
const ReliableTopicMessage_1 = require("../proxy/topic/ReliableTopicMessage");
const Util = require("../util/Util");
const DefaultSerializers_1 = require("./DefaultSerializers");
const HeapData_1 = require("./HeapData");
const ObjectData_1 = require("./ObjectData");
const PortableSerializer_1 = require("./portable/PortableSerializer");
const DefaultPredicates_1 = require("./DefaultPredicates");
const JsonStringDeserializationPolicy_1 = require("../config/JsonStringDeserializationPolicy");
const RestValue_1 = require("../core/RestValue");
const defaultPartitionStrategy = (obj) => {
    if (obj == null || !obj['getPartitionHash']) {
        return 0;
    }
    else {
        return obj.getPartitionHash();
    }
};
/** @internal */
class SerializationServiceV1 {
    constructor(serializationConfig) {
        this.serializationConfig = serializationConfig;
        this.registry = {};
        this.serializerNameToId = {};
        this.registerDefaultSerializers();
        this.registerCustomSerializers();
        this.registerGlobalSerializer();
    }
    isData(object) {
        if (object instanceof HeapData_1.HeapData) {
            return true;
        }
        else {
            return false;
        }
    }
    toData(object, partitioningStrategy = defaultPartitionStrategy) {
        if (this.isData(object)) {
            return object;
        }
        const dataOutput = new ObjectData_1.PositionalObjectDataOutput(this, this.serializationConfig.isBigEndian);
        const serializer = this.findSerializerFor(object);
        // Check if object is partition aware
        if (object != null && object.partitionKey != null) {
            const partitionKey = object.partitionKey;
            const serializedPartitionKey = this.toData(partitionKey);
            dataOutput.writeIntBE(this.calculatePartitionHash(serializedPartitionKey, partitioningStrategy));
        }
        else {
            dataOutput.writeIntBE(this.calculatePartitionHash(object, partitioningStrategy));
        }
        dataOutput.writeIntBE(serializer.id);
        serializer.write(dataOutput, object);
        return new HeapData_1.HeapData(dataOutput.toBuffer());
    }
    toObject(data) {
        if (data == null) {
            return data;
        }
        if (!data.getType) {
            return data;
        }
        const serializer = this.findSerializerById(data.getType());
        const dataInput = new ObjectData_1.ObjectDataInput(data.toBuffer(), HeapData_1.DATA_OFFSET, this, this.serializationConfig.isBigEndian);
        return serializer.read(dataInput);
    }
    writeObject(out, object) {
        const serializer = this.findSerializerFor(object);
        out.writeInt(serializer.id);
        serializer.write(out, object);
    }
    readObject(inp) {
        const serializerId = inp.readInt();
        const serializer = this.findSerializerById(serializerId);
        return serializer.read(inp);
    }
    registerSerializer(name, serializer) {
        if (this.serializerNameToId[name]) {
            throw new RangeError('Given serializer name is already in the registry.');
        }
        if (this.registry[serializer.id]) {
            throw new RangeError('Given serializer id is already in the registry.');
        }
        this.serializerNameToId[name] = serializer.id;
        this.registry[serializer.id] = serializer;
    }
    /**
     * Serialization precedence
     *  1. NULL
     *  2. DataSerializable
     *  3. Portable
     *  4. Default Types
     *      * Byte, Boolean, Character, Short, Integer, Long, Float, Double, String
     *      * Array of [Byte, Boolean, Character, Short, Integer, Long, Float, Double, String]
     *      * Java types [Date, BigInteger, BigDecimal, Class, Enum]
     *  5. Custom serializers
     *  6. Global Serializer
     *  7. Fallback (JSON)
     * @param obj
     * @returns
     */
    findSerializerFor(obj) {
        if (obj === undefined) {
            throw new RangeError('undefined cannot be serialized.');
        }
        let serializer = null;
        if (obj === null) {
            serializer = this.findSerializerByName('null', false);
        }
        if (serializer === null) {
            serializer = this.lookupDefaultSerializer(obj);
        }
        if (serializer === null) {
            serializer = this.lookupCustomSerializer(obj);
        }
        if (serializer === null) {
            serializer = this.lookupGlobalSerializer();
        }
        if (serializer === null) {
            serializer = this.findSerializerByName('!json', false);
        }
        if (serializer === null) {
            throw new RangeError('There is no suitable serializer for ' + obj + '.');
        }
        return serializer;
    }
    lookupDefaultSerializer(obj) {
        let serializer = null;
        if (this.isIdentifiedDataSerializable(obj)) {
            return this.findSerializerByName('identified', false);
        }
        if (this.isPortableSerializable(obj)) {
            return this.findSerializerByName('!portable', false);
        }
        const objectType = Util.getType(obj);
        if (objectType === 'array') {
            if (obj.length === 0) {
                serializer = this.findSerializerByName('number', true);
            }
            else {
                serializer = this.findSerializerByName(Util.getType(obj[0]), true);
            }
        }
        else {
            serializer = this.findSerializerByName(objectType, false);
        }
        return serializer;
    }
    lookupCustomSerializer(obj) {
        if (this.isCustomSerializable(obj)) {
            return this.findSerializerById(obj.hzCustomId);
        }
        return null;
    }
    lookupGlobalSerializer() {
        return this.findSerializerByName('!global', false);
    }
    isIdentifiedDataSerializable(obj) {
        return (obj.readData && obj.writeData
            && typeof obj.factoryId === 'number' && typeof obj.classId === 'number');
    }
    isPortableSerializable(obj) {
        return (obj.readPortable && obj.writePortable
            && typeof obj.factoryId === 'number' && typeof obj.classId === 'number');
    }
    registerDefaultSerializers() {
        this.registerSerializer('string', new DefaultSerializers_1.StringSerializer());
        this.registerSerializer('double', new DefaultSerializers_1.DoubleSerializer());
        this.registerSerializer('byte', new DefaultSerializers_1.ByteSerializer());
        this.registerSerializer('boolean', new DefaultSerializers_1.BooleanSerializer());
        this.registerSerializer('null', new DefaultSerializers_1.NullSerializer());
        this.registerSerializer('short', new DefaultSerializers_1.ShortSerializer());
        this.registerSerializer('integer', new DefaultSerializers_1.IntegerSerializer());
        this.registerSerializer('long', new DefaultSerializers_1.LongSerializer());
        this.registerSerializer('float', new DefaultSerializers_1.FloatSerializer());
        this.registerSerializer('char', new DefaultSerializers_1.CharSerializer());
        this.registerSerializer('date', new DefaultSerializers_1.DateSerializer());
        this.registerSerializer('byteArray', new DefaultSerializers_1.ByteArraySerializer());
        this.registerSerializer('charArray', new DefaultSerializers_1.CharArraySerializer());
        this.registerSerializer('booleanArray', new DefaultSerializers_1.BooleanArraySerializer());
        this.registerSerializer('shortArray', new DefaultSerializers_1.ShortArraySerializer());
        this.registerSerializer('integerArray', new DefaultSerializers_1.IntegerArraySerializer());
        this.registerSerializer('longArray', new DefaultSerializers_1.LongArraySerializer());
        this.registerSerializer('doubleArray', new DefaultSerializers_1.DoubleArraySerializer());
        this.registerSerializer('stringArray', new DefaultSerializers_1.StringArraySerializer());
        this.registerSerializer('javaClass', new DefaultSerializers_1.JavaClassSerializer());
        this.registerSerializer('floatArray', new DefaultSerializers_1.FloatArraySerializer());
        this.registerSerializer('uuid', new DefaultSerializers_1.UuidSerializer());
        this.registerIdentifiedFactories();
        this.registerSerializer('!portable', new PortableSerializer_1.PortableSerializer(this.serializationConfig));
        if (this.serializationConfig.jsonStringDeserializationPolicy === JsonStringDeserializationPolicy_1.JsonStringDeserializationPolicy.EAGER) {
            this.registerSerializer('!json', new DefaultSerializers_1.JsonSerializer());
        }
        else {
            this.registerSerializer('!json', new DefaultSerializers_1.HazelcastJsonValueSerializer());
        }
    }
    registerIdentifiedFactories() {
        const factories = {};
        for (const id in this.serializationConfig.dataSerializableFactories) {
            factories[id] = this.serializationConfig.dataSerializableFactories[id];
        }
        factories[DefaultPredicates_1.PREDICATE_FACTORY_ID] = DefaultPredicates_1.predicateFactory;
        factories[ReliableTopicMessage_1.RELIABLE_TOPIC_MESSAGE_FACTORY_ID] = ReliableTopicMessage_1.reliableTopicMessageFactory;
        factories[ClusterDataFactory_1.CLUSTER_DATA_FACTORY_ID] = ClusterDataFactory_1.clusterDataFactory;
        factories[AggregatorFactory_1.AGGREGATOR_FACTORY_ID] = AggregatorFactory_1.aggregatorFactory;
        factories[RestValue_1.REST_VALUE_FACTORY_ID] = RestValue_1.restValueFactory;
        this.registerSerializer('identified', new DefaultSerializers_1.IdentifiedDataSerializableSerializer(factories));
    }
    registerCustomSerializers() {
        const customSerializers = this.serializationConfig.customSerializers;
        for (const key in customSerializers) {
            const candidate = customSerializers[key];
            this.assertValidCustomSerializer(candidate);
            this.registerSerializer('!custom' + candidate.id, candidate);
        }
    }
    registerGlobalSerializer() {
        const candidate = this.serializationConfig.globalSerializer;
        if (candidate == null) {
            return;
        }
        this.assertValidCustomSerializer(candidate);
        this.registerSerializer('!global', candidate);
    }
    assertValidCustomSerializer(candidate) {
        const idProp = 'id';
        const fRead = 'read';
        const fWrite = 'write';
        if (typeof candidate[idProp] !== 'number') {
            throw new TypeError('Custom serializer should have ' + idProp + ' property.');
        }
        if (typeof candidate[fRead] !== 'function' || typeof candidate[fWrite] !== 'function') {
            throw new TypeError('Custom serializer should have ' + fRead + ' and ' + fWrite + ' methods.');
        }
        const typeId = candidate[idProp];
        if (!Number.isInteger(typeId) || typeId < 1) {
            throw new TypeError('Custom serializer should have its typeId greater than or equal to 1.');
        }
    }
    isCustomSerializable(object) {
        const prop = 'hzCustomId';
        return (typeof object[prop] === 'number' && object[prop] >= 1);
    }
    findSerializerByName(name, isArray) {
        let convertedName;
        if (name === 'number') {
            convertedName = this.serializationConfig.defaultNumberType;
        }
        else if (name === 'buffer') {
            convertedName = 'byteArray';
        }
        else {
            convertedName = name;
        }
        const serializerName = convertedName + (isArray ? 'Array' : '');
        const serializerId = this.serializerNameToId[serializerName];
        if (serializerId == null) {
            return null;
        }
        return this.findSerializerById(serializerId);
    }
    findSerializerById(id) {
        const serializer = this.registry[id];
        return serializer;
    }
    calculatePartitionHash(object, strategy) {
        return strategy(object);
    }
}
exports.SerializationServiceV1 = SerializationServiceV1;
