"use strict";
/*
 * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @ignore */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListenerService = void 0;
const core_1 = require("../core");
const ClientEventRegistration_1 = require("../invocation/ClientEventRegistration");
const InvocationService_1 = require("../invocation/InvocationService");
const RegistrationKey_1 = require("../invocation/RegistrationKey");
const Util_1 = require("../util/Util");
const UuidUtil_1 = require("../util/UuidUtil");
/** @internal */
class ListenerService {
    constructor(client) {
        this.client = client;
        this.logger = this.client.getLoggingService().getLogger();
        this.isSmartService = this.client.getConfig().network.smartRouting;
        this.activeRegistrations = new Map();
        this.userKeyInformation = new Map();
    }
    start() {
        this.client.getConnectionManager().on('connectionAdded', this.onConnectionAdded.bind(this));
        this.client.getConnectionManager().on('connectionRemoved', this.onConnectionRemoved.bind(this));
    }
    onConnectionAdded(connection) {
        this.reregisterListenersOnConnection(connection);
    }
    onConnectionRemoved(connection) {
        this.removeRegistrationsOnConnection(connection);
    }
    reregisterListenersOnConnection(connection) {
        this.activeRegistrations.forEach((registrationMap, userKey) => {
            if (registrationMap.has(connection)) {
                return;
            }
            this.invokeRegistrationFromRecord(userKey, connection).then((eventRegistration) => {
                // handle potential race with deregisterListener
                // which might have deleted the registration
                if (this.userKeyInformation.get(userKey) === undefined) {
                    this.deregisterListenerOnTarget(userKey, eventRegistration);
                    return;
                }
                registrationMap.set(connection, eventRegistration);
            }).catch((err) => {
                this.logger.warn('ListenerService', err);
            });
        }, this);
    }
    removeRegistrationsOnConnection(connection) {
        this.activeRegistrations.forEach((registrationsOnUserKey) => {
            const eventRegistration = registrationsOnUserKey.get(connection);
            if (eventRegistration !== undefined) {
                this.client.getInvocationService().removeEventHandler(eventRegistration.correlationId);
            }
        });
    }
    invokeRegistrationFromRecord(userKey, connection) {
        const deferred = Util_1.deferredPromise();
        const activeRegsOnUserKey = this.activeRegistrations.get(userKey);
        if (activeRegsOnUserKey !== undefined && activeRegsOnUserKey.has(connection)) {
            deferred.resolve(activeRegsOnUserKey.get(connection));
            return deferred.promise;
        }
        const registrationKey = this.userKeyInformation.get(userKey);
        // New correlation id will be set on the invoke call
        const registerRequest = registrationKey.getRegisterRequest().copyWithNewCorrelationId();
        const codec = registrationKey.getCodec();
        const invocation = new InvocationService_1.Invocation(this.client, registerRequest);
        invocation.handler = registrationKey.getHandler();
        invocation.connection = connection;
        this.client.getInvocationService().invokeUrgent(invocation).then((responseMessage) => {
            const correlationId = responseMessage.getCorrelationId();
            const response = codec.decodeAddResponse(responseMessage);
            const eventRegistration = new ClientEventRegistration_1.ClientEventRegistration(response, correlationId, invocation.connection, codec);
            this.logger.debug('ListenerService', 'Listener ' + userKey + ' re-registered on ' + connection.toString());
            deferred.resolve(eventRegistration);
        }).catch(((err) => {
            deferred.reject(new core_1.HazelcastError('Could not add listener[' + userKey +
                '] to connection[' + connection.toString() + ']', err));
        }));
        return deferred.promise;
    }
    registerListener(codec, listenerHandlerFn) {
        const activeConnections = this.client.getConnectionManager().getActiveConnections();
        const userKey = UuidUtil_1.UuidUtil.generate().toString();
        let connectionsOnUserKey;
        const registerRequest = codec.encodeAddRequest(this.isSmart());
        connectionsOnUserKey = this.activeRegistrations.get(userKey);
        if (connectionsOnUserKey === undefined) {
            connectionsOnUserKey = new Map();
            this.activeRegistrations.set(userKey, connectionsOnUserKey);
            this.userKeyInformation.set(userKey, new RegistrationKey_1.RegistrationKey(userKey, codec, registerRequest, listenerHandlerFn));
        }
        const registrationPromises = [];
        for (const connection of activeConnections) {
            if (connectionsOnUserKey.has(connection)) {
                continue;
            }
            // new correlation id will be set on the invoke call
            const requestCopy = registerRequest.copyWithNewCorrelationId();
            const invocation = new InvocationService_1.Invocation(this.client, requestCopy);
            invocation.handler = listenerHandlerFn;
            invocation.connection = connection;
            const registrationPromise = this.client.getInvocationService().invokeUrgent(invocation)
                .then((responseMessage) => {
                const correlationId = responseMessage.getCorrelationId();
                const response = codec.decodeAddResponse(responseMessage);
                const clientEventRegistration = new ClientEventRegistration_1.ClientEventRegistration(response, correlationId, invocation.connection, codec);
                this.logger.debug('ListenerService', 'Listener ' + userKey + ' registered on ' + invocation.connection.toString());
                connectionsOnUserKey.set(connection, clientEventRegistration);
            })
                .catch((err) => {
                if (invocation.connection.isAlive()) {
                    this.deregisterListener(userKey)
                        .catch(() => {
                        // no-op
                    });
                    throw new core_1.HazelcastError('Listener cannot be added!', err);
                }
            });
            registrationPromises.push(registrationPromise);
        }
        return Promise.all(registrationPromises)
            .then(() => userKey);
    }
    deregisterListener(userKey) {
        const deferred = Util_1.deferredPromise();
        const registrationsOnUserKey = this.activeRegistrations.get(userKey);
        if (registrationsOnUserKey === undefined) {
            deferred.resolve(false);
            return deferred.promise;
        }
        this.activeRegistrations.delete(userKey);
        this.userKeyInformation.delete(userKey);
        registrationsOnUserKey.forEach((eventRegistration, connection) => {
            // remove local handler
            registrationsOnUserKey.delete(connection);
            this.client.getInvocationService().removeEventHandler(eventRegistration.correlationId);
            // the rest is for deleting remote registration
            this.deregisterListenerOnTarget(userKey, eventRegistration);
        });
        deferred.resolve(true);
        return deferred.promise;
    }
    /**
     * Asynchronously de-registers listener on the target associated
     * with the given event registration.
     */
    deregisterListenerOnTarget(userKey, eventRegistration) {
        const clientMessage = eventRegistration.codec.encodeRemoveRequest(eventRegistration.serverRegistrationId);
        // null message means no remote registration (e.g. for backup acks)
        if (clientMessage === null) {
            return;
        }
        const invocation = new InvocationService_1.Invocation(this.client, clientMessage, Number.MAX_SAFE_INTEGER);
        invocation.connection = eventRegistration.subscriber;
        this.client.getInvocationService().invoke(invocation).catch((err) => {
            if (err instanceof core_1.ClientNotActiveError
                || err instanceof core_1.IOError
                || err instanceof core_1.TargetDisconnectedError) {
                return;
            }
            this.logger.warn('ListenerService', 'Deregistration of listener ' + userKey + ' has failed for address '
                + invocation.connection.getRemoteAddress().toString());
        });
    }
    isSmart() {
        return this.isSmartService;
    }
}
exports.ListenerService = ListenerService;
