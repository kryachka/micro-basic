"use strict";
/*
 * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @ignore */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigBuilder = void 0;
const core_1 = require("../core");
const proxy_1 = require("../proxy");
const Util_1 = require("../util/Util");
const Config_1 = require("./Config");
const EvictionPolicy_1 = require("./EvictionPolicy");
const FlakeIdGeneratorConfig_1 = require("./FlakeIdGeneratorConfig");
const InMemoryFormat_1 = require("./InMemoryFormat");
const NearCacheConfig_1 = require("./NearCacheConfig");
const ReliableTopicConfig_1 = require("./ReliableTopicConfig");
const JsonStringDeserializationPolicy_1 = require("./JsonStringDeserializationPolicy");
const ConnectionStrategyConfig_1 = require("./ConnectionStrategyConfig");
const LoadBalancerConfig_1 = require("./LoadBalancerConfig");
/**
 * Responsible for user-defined config validation. Builds the effective config with necessary defaults.
 * @internal
 */
class ConfigBuilder {
    constructor(config) {
        this.effectiveConfig = new Config_1.ClientConfigImpl();
        this.originalConfig = config || {};
    }
    build() {
        try {
            this.handleConfig(this.originalConfig);
            return this.effectiveConfig;
        }
        catch (err) {
            throw new core_1.InvalidConfigurationError('Config validation error: ' + err.message, err);
        }
    }
    handleConfig(jsonObject) {
        for (const key in jsonObject) {
            const value = jsonObject[key];
            if (key === 'clusterName') {
                this.effectiveConfig.clusterName = Util_1.tryGetString(value);
            }
            else if (key === 'instanceName') {
                this.effectiveConfig.instanceName = Util_1.tryGetString(value);
            }
            else if (key === 'properties') {
                this.handleProperties(value);
            }
            else if (key === 'clientLabels') {
                this.handleClientLabels(value);
            }
            else if (key === 'network') {
                this.handleNetwork(value);
            }
            else if (key === 'connectionStrategy') {
                this.handleConnectionStrategy(value);
            }
            else if (key === 'lifecycleListeners') {
                this.handleLifecycleListeners(value);
            }
            else if (key === 'membershipListeners') {
                this.handleMembershipListeners(value);
            }
            else if (key === 'serialization') {
                this.handleSerialization(value);
            }
            else if (key === 'nearCaches') {
                this.handleNearCaches(value);
            }
            else if (key === 'reliableTopics') {
                this.handleReliableTopics(value);
            }
            else if (key === 'flakeIdGenerators') {
                this.handleFlakeIdGenerators(value);
            }
            else if (key === 'loadBalancer') {
                this.handleLoadBalancer(value);
            }
            else if (key === 'customLogger') {
                this.handleLogger(value);
            }
            else if (key === 'customCredentials') {
                this.handleCredentials(value);
            }
            else if (key === 'backupAckToClientEnabled') {
                this.effectiveConfig.backupAckToClientEnabled = Util_1.tryGetBoolean(value);
            }
        }
    }
    handleConnectionStrategy(jsonObject) {
        for (const key in jsonObject) {
            const value = jsonObject[key];
            if (key === 'asyncStart') {
                this.effectiveConfig.connectionStrategy.asyncStart = Util_1.tryGetBoolean(value);
            }
            else if (key === 'reconnectMode') {
                this.effectiveConfig.connectionStrategy.reconnectMode = Util_1.tryGetEnum(ConnectionStrategyConfig_1.ReconnectMode, value);
            }
            else if (key === 'connectionRetry') {
                this.handleConnectionRetry(value);
            }
        }
    }
    handleConnectionRetry(jsonObject) {
        for (const key in jsonObject) {
            const value = jsonObject[key];
            if (key === 'initialBackoffMillis') {
                this.effectiveConfig.connectionStrategy.connectionRetry.initialBackoffMillis = Util_1.tryGetNumber(value);
            }
            else if (key === 'maxBackoffMillis') {
                this.effectiveConfig.connectionStrategy.connectionRetry.maxBackoffMillis = Util_1.tryGetNumber(value);
            }
            else if (key === 'multiplier') {
                this.effectiveConfig.connectionStrategy.connectionRetry.multiplier = Util_1.tryGetNumber(value);
            }
            else if (key === 'clusterConnectTimeoutMillis') {
                this.effectiveConfig.connectionStrategy.connectionRetry
                    .clusterConnectTimeoutMillis = Util_1.tryGetNumber(value);
            }
            else if (key === 'jitter') {
                this.effectiveConfig.connectionStrategy.connectionRetry.jitter = Util_1.tryGetNumber(value);
            }
        }
    }
    handleClientLabels(jsonObject) {
        const labelsArray = Util_1.tryGetArray(jsonObject);
        for (const index in labelsArray) {
            const label = labelsArray[index];
            this.effectiveConfig.clientLabels.push(label);
        }
    }
    handleNetwork(jsonObject) {
        for (const key in jsonObject) {
            if (key === 'clusterMembers') {
                this.handleClusterMembers(jsonObject[key]);
            }
            else if (key === 'smartRouting') {
                this.effectiveConfig.network.smartRouting = Util_1.tryGetBoolean(jsonObject[key]);
            }
            else if (key === 'redoOperation') {
                this.effectiveConfig.network.redoOperation = Util_1.tryGetBoolean(jsonObject[key]);
            }
            else if (key === 'connectionTimeout') {
                this.effectiveConfig.network.connectionTimeout = Util_1.tryGetNumber(jsonObject[key]);
            }
            else if (key === 'ssl') {
                this.handleSSL(jsonObject[key]);
            }
            else if (key === 'hazelcastCloud') {
                this.handleHazelcastCloud(jsonObject[key]);
            }
        }
    }
    handleHazelcastCloud(jsonObject) {
        for (const key in jsonObject) {
            if (key === 'discoveryToken') {
                this.effectiveConfig.network.hazelcastCloud.discoveryToken = Util_1.tryGetString(jsonObject[key]);
            }
        }
    }
    parseProperties(jsonObject) {
        const props = {};
        for (const key in jsonObject) {
            props[key] = jsonObject[key];
        }
        return props;
    }
    handleSSL(jsonObject) {
        const sslEnabled = Util_1.tryGetBoolean(jsonObject.enabled);
        this.effectiveConfig.network.ssl.enabled = sslEnabled;
        if (jsonObject.sslOptions) {
            if (jsonObject.sslOptionsFactory || jsonObject.sslOptionsFactoryProperties) {
                throw new RangeError('Invalid configuration. Either SSL options should be set manually or SSL factory'
                    + ' should be used.');
            }
            this.effectiveConfig.network.ssl.sslOptions = jsonObject.sslOptions;
        }
        else if (jsonObject.sslOptionsFactory || jsonObject.sslOptionsFactoryProperties) {
            this.effectiveConfig.network.ssl.sslOptionsFactory = jsonObject.sslOptionsFactory;
            this.effectiveConfig.network.ssl.sslOptionsFactoryProperties = jsonObject.sslOptionsFactoryProperties
                ? this.parseProperties(jsonObject.sslOptionsFactoryProperties) : null;
        }
    }
    handleClusterMembers(jsonObject) {
        const addressArray = Util_1.tryGetArray(jsonObject);
        for (const index in addressArray) {
            const address = addressArray[index];
            this.effectiveConfig.network.clusterMembers.push(Util_1.tryGetString(address));
        }
    }
    handleProperties(jsonObject) {
        for (const key in jsonObject) {
            this.effectiveConfig.properties[key] = jsonObject[key];
        }
    }
    handleLifecycleListeners(jsonObject) {
        const listenersArray = Util_1.tryGetArray(jsonObject);
        for (const index in listenersArray) {
            const listener = listenersArray[index];
            this.effectiveConfig.lifecycleListeners.push(listener);
        }
    }
    handleMembershipListeners(jsonObject) {
        const listenersArray = Util_1.tryGetArray(jsonObject);
        for (const index in listenersArray) {
            const listener = listenersArray[index];
            this.effectiveConfig.membershipListeners.push(listener);
        }
    }
    handleSerialization(jsonObject) {
        for (const key in jsonObject) {
            if (key === 'defaultNumberType') {
                this.effectiveConfig.serialization.defaultNumberType = Util_1.tryGetString(jsonObject[key]);
            }
            else if (key === 'isBigEndian') {
                this.effectiveConfig.serialization.isBigEndian = Util_1.tryGetBoolean(jsonObject[key]);
            }
            else if (key === 'portableVersion') {
                this.effectiveConfig.serialization.portableVersion = Util_1.tryGetNumber(jsonObject[key]);
            }
            else if (key === 'dataSerializableFactories') {
                for (const index in jsonObject[key]) {
                    const idx = Number.parseInt(index);
                    this.effectiveConfig.serialization
                        .dataSerializableFactories[idx] = jsonObject[key][index];
                }
            }
            else if (key === 'portableFactories') {
                for (const index in jsonObject[key]) {
                    const idx = Number.parseInt(index);
                    this.effectiveConfig.serialization
                        .portableFactories[idx] = jsonObject[key][index];
                }
            }
            else if (key === 'globalSerializer') {
                const globalSerializer = jsonObject[key];
                this.effectiveConfig.serialization.globalSerializer = globalSerializer;
            }
            else if (key === 'customSerializers') {
                this.handleCustomSerializers(jsonObject[key]);
            }
            else if (key === 'jsonStringDeserializationPolicy') {
                this.effectiveConfig.serialization
                    .jsonStringDeserializationPolicy = Util_1.tryGetEnum(JsonStringDeserializationPolicy_1.JsonStringDeserializationPolicy, jsonObject[key]);
            }
        }
    }
    handleCustomSerializers(jsonObject) {
        const serializersArray = Util_1.tryGetArray(jsonObject);
        for (const index in serializersArray) {
            const serializer = serializersArray[index];
            this.effectiveConfig.serialization.customSerializers.push(serializer);
        }
    }
    handleNearCaches(jsonObject) {
        for (const key in jsonObject) {
            const ncConfig = jsonObject[key];
            const nearCacheConfig = new NearCacheConfig_1.NearCacheConfigImpl();
            nearCacheConfig.name = key;
            for (const name in ncConfig) {
                if (name === 'invalidateOnChange') {
                    nearCacheConfig.invalidateOnChange = Util_1.tryGetBoolean(ncConfig[name]);
                }
                else if (name === 'maxIdleSeconds') {
                    nearCacheConfig.maxIdleSeconds = Util_1.tryGetNumber(ncConfig[name]);
                }
                else if (name === 'inMemoryFormat') {
                    nearCacheConfig.inMemoryFormat = Util_1.tryGetEnum(InMemoryFormat_1.InMemoryFormat, ncConfig[name]);
                }
                else if (name === 'timeToLiveSeconds') {
                    nearCacheConfig.timeToLiveSeconds = Util_1.tryGetNumber(ncConfig[name]);
                }
                else if (name === 'evictionPolicy') {
                    nearCacheConfig.evictionPolicy = Util_1.tryGetEnum(EvictionPolicy_1.EvictionPolicy, ncConfig[name]);
                }
                else if (name === 'evictionMaxSize') {
                    nearCacheConfig.evictionMaxSize = Util_1.tryGetNumber(ncConfig[name]);
                }
                else if (name === 'evictionSamplingCount') {
                    nearCacheConfig.evictionSamplingCount = Util_1.tryGetNumber(ncConfig[name]);
                }
                else if (name === 'evictionSamplingPoolSize') {
                    nearCacheConfig.evictionSamplingPoolSize = Util_1.tryGetNumber(ncConfig[name]);
                }
            }
            this.effectiveConfig.nearCaches[nearCacheConfig.name] = nearCacheConfig;
        }
    }
    handleReliableTopics(jsonObject) {
        for (const key in jsonObject) {
            const jsonRtCfg = jsonObject[key];
            const reliableTopicConfig = new ReliableTopicConfig_1.ReliableTopicConfigImpl();
            reliableTopicConfig.name = key;
            for (const name in jsonRtCfg) {
                if (name === 'readBatchSize') {
                    reliableTopicConfig.readBatchSize = jsonRtCfg[name];
                }
                else if (name === 'overloadPolicy') {
                    reliableTopicConfig.overloadPolicy = Util_1.tryGetEnum(proxy_1.TopicOverloadPolicy, jsonRtCfg[name]);
                }
            }
            this.effectiveConfig.reliableTopics[reliableTopicConfig.name] = reliableTopicConfig;
        }
    }
    handleFlakeIdGenerators(jsonObject) {
        for (const key in jsonObject) {
            const fidConfig = jsonObject[key];
            const flakeIdConfig = new FlakeIdGeneratorConfig_1.FlakeIdGeneratorConfigImpl();
            flakeIdConfig.name = key;
            for (const name in fidConfig) {
                if (name === 'prefetchCount') {
                    flakeIdConfig.prefetchCount = Util_1.tryGetNumber(fidConfig[name]);
                }
                else if (name === 'prefetchValidityMillis') {
                    flakeIdConfig.prefetchValidityMillis = Util_1.tryGetNumber(fidConfig[name]);
                }
            }
            this.effectiveConfig.flakeIdGenerators[flakeIdConfig.name] = flakeIdConfig;
        }
    }
    handleLoadBalancer(jsonObject) {
        for (const key in jsonObject) {
            if (key === 'type') {
                this.effectiveConfig.loadBalancer.type = Util_1.tryGetEnum(LoadBalancerConfig_1.LoadBalancerType, jsonObject[key]);
            }
            else if (key === 'customLoadBalancer') {
                this.effectiveConfig.loadBalancer.customLoadBalancer = jsonObject[key];
            }
        }
    }
    handleLogger(jsonObject) {
        this.effectiveConfig.customLogger = jsonObject;
    }
    handleCredentials(jsonObject) {
        this.effectiveConfig.customCredentials = jsonObject;
    }
}
exports.ConfigBuilder = ConfigBuilder;
