"use strict";
/*
 * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @ignore */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiMapProxy = void 0;
const MultiMapForceUnlockCodec_1 = require("../codec/MultiMapForceUnlockCodec");
const MultiMapIsLockedCodec_1 = require("../codec/MultiMapIsLockedCodec");
const MultiMapLockCodec_1 = require("../codec/MultiMapLockCodec");
const MultiMapTryLockCodec_1 = require("../codec/MultiMapTryLockCodec");
const MultiMapUnlockCodec_1 = require("../codec/MultiMapUnlockCodec");
const EventType_1 = require("./EventType");
const EntryListener_1 = require("./EntryListener");
const MultiMapAddEntryListenerCodec_1 = require("../codec/MultiMapAddEntryListenerCodec");
const MultiMapAddEntryListenerToKeyCodec_1 = require("../codec/MultiMapAddEntryListenerToKeyCodec");
const MultiMapClearCodec_1 = require("../codec/MultiMapClearCodec");
const MultiMapContainsEntryCodec_1 = require("../codec/MultiMapContainsEntryCodec");
const MultiMapContainsKeyCodec_1 = require("../codec/MultiMapContainsKeyCodec");
const MultiMapContainsValueCodec_1 = require("../codec/MultiMapContainsValueCodec");
const MultiMapEntrySetCodec_1 = require("../codec/MultiMapEntrySetCodec");
const MultiMapGetCodec_1 = require("../codec/MultiMapGetCodec");
const MultiMapKeySetCodec_1 = require("../codec/MultiMapKeySetCodec");
const MultiMapPutCodec_1 = require("../codec/MultiMapPutCodec");
const MultiMapRemoveCodec_1 = require("../codec/MultiMapRemoveCodec");
const MultiMapRemoveEntryCodec_1 = require("../codec/MultiMapRemoveEntryCodec");
const MultiMapRemoveEntryListenerCodec_1 = require("../codec/MultiMapRemoveEntryListenerCodec");
const MultiMapSizeCodec_1 = require("../codec/MultiMapSizeCodec");
const MultiMapValueCountCodec_1 = require("../codec/MultiMapValueCountCodec");
const MultiMapValuesCodec_1 = require("../codec/MultiMapValuesCodec");
const BaseProxy_1 = require("./BaseProxy");
const MapListener_1 = require("./MapListener");
const core_1 = require("../core");
const SerializationUtil = require("../serialization/SerializationUtil");
const MultiMapPutAllCodec_1 = require("../codec/MultiMapPutAllCodec");
/** @internal */
class MultiMapProxy extends BaseProxy_1.BaseProxy {
    constructor() {
        super(...arguments);
        this.lockReferenceIdGenerator = this.client.getLockReferenceIdGenerator();
        this.deserializeList = (items) => {
            return items.map(this.toObject.bind(this));
        };
    }
    put(key, value) {
        const keyData = this.toData(key);
        const valueData = this.toData(value);
        return this.encodeInvokeOnKey(MultiMapPutCodec_1.MultiMapPutCodec, keyData, keyData, valueData, 1)
            .then(MultiMapPutCodec_1.MultiMapPutCodec.decodeResponse);
    }
    get(key) {
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(MultiMapGetCodec_1.MultiMapGetCodec, keyData, keyData, 1)
            .then((clientMessage) => {
            const response = MultiMapGetCodec_1.MultiMapGetCodec.decodeResponse(clientMessage);
            return new core_1.ReadOnlyLazyList(response, this.client.getSerializationService());
        });
    }
    remove(key, value) {
        const keyData = this.toData(key);
        const valueData = this.toData(value);
        return this.encodeInvokeOnKey(MultiMapRemoveEntryCodec_1.MultiMapRemoveEntryCodec, keyData, keyData, valueData, 1)
            .then(MultiMapRemoveEntryCodec_1.MultiMapRemoveEntryCodec.decodeResponse);
    }
    removeAll(key) {
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(MultiMapRemoveCodec_1.MultiMapRemoveCodec, keyData, keyData, 1)
            .then((clientMessage) => {
            const response = MultiMapRemoveCodec_1.MultiMapRemoveCodec.decodeResponse(clientMessage);
            return new core_1.ReadOnlyLazyList(response, this.client.getSerializationService());
        });
    }
    keySet() {
        return this.encodeInvokeOnRandomTarget(MultiMapKeySetCodec_1.MultiMapKeySetCodec)
            .then((clientMessage) => {
            const response = MultiMapKeySetCodec_1.MultiMapKeySetCodec.decodeResponse(clientMessage);
            return this.deserializeList(response);
        });
    }
    values() {
        return this.encodeInvokeOnRandomTarget(MultiMapValuesCodec_1.MultiMapValuesCodec)
            .then((clientMessage) => {
            const response = MultiMapValuesCodec_1.MultiMapValuesCodec.decodeResponse(clientMessage);
            return new core_1.ReadOnlyLazyList(response, this.client.getSerializationService());
        });
    }
    entrySet() {
        return this.encodeInvokeOnRandomTarget(MultiMapEntrySetCodec_1.MultiMapEntrySetCodec)
            .then((clientMessage) => {
            const response = MultiMapEntrySetCodec_1.MultiMapEntrySetCodec.decodeResponse(clientMessage);
            return SerializationUtil.deserializeEntryList(this.toObject.bind(this), response);
        });
    }
    containsKey(key) {
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(MultiMapContainsKeyCodec_1.MultiMapContainsKeyCodec, keyData, keyData, 1)
            .then(MultiMapContainsKeyCodec_1.MultiMapContainsKeyCodec.decodeResponse);
    }
    containsValue(value) {
        const valueData = this.toData(value);
        return this.encodeInvokeOnRandomTarget(MultiMapContainsValueCodec_1.MultiMapContainsValueCodec, valueData)
            .then(MultiMapContainsValueCodec_1.MultiMapContainsValueCodec.decodeResponse);
    }
    containsEntry(key, value) {
        const keyData = this.toData(key);
        const valueData = this.toData(value);
        return this.encodeInvokeOnKey(MultiMapContainsEntryCodec_1.MultiMapContainsEntryCodec, keyData, keyData, valueData, 1)
            .then(MultiMapContainsEntryCodec_1.MultiMapContainsEntryCodec.decodeResponse);
    }
    size() {
        return this.encodeInvokeOnRandomTarget(MultiMapSizeCodec_1.MultiMapSizeCodec)
            .then(MultiMapSizeCodec_1.MultiMapSizeCodec.decodeResponse);
    }
    clear() {
        return this.encodeInvokeOnRandomTarget(MultiMapClearCodec_1.MultiMapClearCodec).then(() => { });
    }
    valueCount(key) {
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(MultiMapValueCountCodec_1.MultiMapValueCountCodec, keyData, keyData, 1)
            .then(MultiMapValueCountCodec_1.MultiMapValueCountCodec.decodeResponse);
    }
    addEntryListener(listener, key, includeValue = true) {
        const toObject = this.toObject.bind(this);
        const entryEventHandler = (keyData, valueData, oldValueData, mergingValueData, eventType, uuid, numberOfAffectedEntries) => {
            const member = this.client.getClusterService().getMember(uuid);
            const name = this.name;
            key = toObject(keyData);
            const value = toObject(valueData);
            const oldValue = toObject(oldValueData);
            const mergingValue = toObject(mergingValueData);
            const entryEvent = new EntryListener_1.EntryEvent(name, key, value, oldValue, mergingValue, member);
            const mapEvent = new MapListener_1.MapEvent(name, numberOfAffectedEntries, member);
            // Multi map only supports these three event types
            switch (eventType) {
                case EventType_1.EventType.ADDED:
                    if (listener.added) {
                        listener.added.apply(null, [entryEvent]);
                    }
                    break;
                case EventType_1.EventType.REMOVED:
                    if (listener.removed) {
                        listener.removed.apply(null, [entryEvent]);
                    }
                    break;
                case EventType_1.EventType.CLEAR_ALL:
                    if (listener.mapCleared) {
                        listener.mapCleared.apply(null, [mapEvent]);
                    }
                    break;
            }
        };
        if (key) {
            const keyData = this.toData(key);
            const handler = (m) => {
                MultiMapAddEntryListenerToKeyCodec_1.MultiMapAddEntryListenerToKeyCodec.handle(m, entryEventHandler);
            };
            const codec = this.createEntryListenerToKey(this.name, keyData, includeValue);
            return this.client.getListenerService().registerListener(codec, handler);
        }
        else {
            const listenerHandler = (m) => {
                MultiMapAddEntryListenerCodec_1.MultiMapAddEntryListenerCodec.handle(m, entryEventHandler);
            };
            const codec = this.createEntryListener(this.name, includeValue);
            return this.client.getListenerService().registerListener(codec, listenerHandler);
        }
    }
    removeEntryListener(listenerId) {
        return this.client.getListenerService().deregisterListener(listenerId);
    }
    lock(key, leaseMillis = -1) {
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(MultiMapLockCodec_1.MultiMapLockCodec, keyData, keyData, 1, leaseMillis, this.nextSequence()).then(() => { });
    }
    isLocked(key) {
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(MultiMapIsLockedCodec_1.MultiMapIsLockedCodec, keyData, keyData)
            .then(MultiMapIsLockedCodec_1.MultiMapIsLockedCodec.decodeResponse);
    }
    tryLock(key, timeoutMillis = 0, leaseMillis = -1) {
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(MultiMapTryLockCodec_1.MultiMapTryLockCodec, keyData, keyData, 1, leaseMillis, timeoutMillis, this.nextSequence()).then(MultiMapTryLockCodec_1.MultiMapTryLockCodec.decodeResponse);
    }
    unlock(key) {
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(MultiMapUnlockCodec_1.MultiMapUnlockCodec, keyData, keyData, 1, this.nextSequence())
            .then(() => { });
    }
    forceUnlock(key) {
        const keyData = this.toData(key);
        return this.encodeInvokeOnKey(MultiMapForceUnlockCodec_1.MultiMapForceUnlockCodec, keyData, keyData, this.nextSequence())
            .then(() => { });
    }
    putAll(pairs) {
        if (pairs.length === 0) {
            return Promise.resolve();
        }
        const dataPairs = [];
        for (const pair of pairs) {
            const valuesData = SerializationUtil.serializeList(this.toData.bind(this), pair[1]);
            dataPairs.push([this.toData(pair[0]), valuesData]);
        }
        const partitionService = this.client.getPartitionService();
        const partitionToDataPairs = new Map();
        for (const dataPair of dataPairs) {
            const partitionId = partitionService.getPartitionId(dataPair[0]);
            let partitionedDataPairs = partitionToDataPairs.get(partitionId);
            if (partitionedDataPairs == null) {
                partitionedDataPairs = [];
                partitionToDataPairs.set(partitionId, partitionedDataPairs);
            }
            partitionedDataPairs.push(dataPair);
        }
        const partitionPromises = [];
        partitionToDataPairs.forEach((pair, partitionId) => {
            partitionPromises.push(this.encodeInvokeOnPartition(MultiMapPutAllCodec_1.MultiMapPutAllCodec, partitionId, pair));
        });
        return Promise.all(partitionPromises).then(() => { });
    }
    nextSequence() {
        return this.lockReferenceIdGenerator.getNextReferenceId();
    }
    createEntryListenerToKey(name, keyData, includeValue) {
        return {
            encodeAddRequest(localOnly) {
                return MultiMapAddEntryListenerToKeyCodec_1.MultiMapAddEntryListenerToKeyCodec.encodeRequest(name, keyData, includeValue, localOnly);
            },
            decodeAddResponse(msg) {
                return MultiMapAddEntryListenerToKeyCodec_1.MultiMapAddEntryListenerToKeyCodec.decodeResponse(msg);
            },
            encodeRemoveRequest(listenerId) {
                return MultiMapRemoveEntryListenerCodec_1.MultiMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);
            },
        };
    }
    createEntryListener(name, includeValue) {
        return {
            encodeAddRequest(localOnly) {
                return MultiMapAddEntryListenerCodec_1.MultiMapAddEntryListenerCodec.encodeRequest(name, includeValue, localOnly);
            },
            decodeAddResponse(msg) {
                return MultiMapAddEntryListenerCodec_1.MultiMapAddEntryListenerCodec.decodeResponse(msg);
            },
            encodeRemoveRequest(listenerId) {
                return MultiMapRemoveEntryListenerCodec_1.MultiMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);
            },
        };
    }
}
exports.MultiMapProxy = MultiMapProxy;
